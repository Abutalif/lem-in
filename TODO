[TODO]
1. find a way to switch between pathfinders, if there are two many steps.  (example1)
2. Standartize error message. Every message should start with "ERROR: invalid data format,. Use errors.Join().
3. Consider chaning your slices of pointers to either no pointer slices or Maps to pointers. Do it after benchmark testing.
4. In case if pathfinder finds num of path that is results in too many steps,
    there must be a function that changes a pathfinder.
    I have to mathematically find which path,
    depending on paths' length and num of ants results in smallest num of steps.

[Suggestions]
1. Might actaully try this (Dijkstra goroutine):
    https://stackoverflow.com/questions/70156258/golang-dijkstra-goroutines
2. Consider not following ants order.
3. Thank you for providing the function.
    Based on the provided code, here are some suggestions for optimizing and improving performance:

    Preallocate Slices: Instead of repeatedly allocating slices (usedPath, step, queue), you can preallocate them with the expected capacity. This can help avoid frequent reallocations and improve performance. You can estimate a reasonable initial capacity based on the size of the input data or use an upper bound if the size is unknown.

    Use a Map for Faster Lookup: Instead of iterating over the usedPath slice to check if a node has already been visited, you can use a map for faster lookup. Maintain a map where the keys are the visited nodes, allowing you to quickly check if a node is already present. This can significantly reduce the time complexity from O(n) to O(1).

    Minimize Slice Appends: The append operation inside the inner loop (usedPath = append(usedPath, order[i])) can be costly, especially as the size of the usedPath slice grows. If possible, consider using a different data structure or approach that avoids frequent appends.

    Avoid Redundant Nil Checks: The final loop (for _, j := range order) iterates over the order slice to count the number of nil elements (nilCounter). Instead of checking for nil elements separately, you can keep track of the count while iterating through the ants in the inner loop. This eliminates the need for an additional loop and improves efficiency.

    Consider Concurrency: Depending on the nature of your problem, you might consider utilizing concurrency to process ants concurrently. By distributing the work among goroutines, you can potentially improve performance by leveraging multiple CPU cores.

    Remember to profile your code and conduct benchmarks to measure the impact of these optimizations. The actual performance gain may vary based on the specific characteristics of your data and system.
4. Certainly! Here are some suggestions on how to conduct benchmarks in Go:

    Use the testing package: Go provides a built-in testing package that includes support for writing benchmarks. By creating benchmark functions and running them with the testing framework, you can easily conduct and compare benchmarks.

    Prefix benchmark functions with "Benchmark": To write a benchmark, create a function with a name starting with "Benchmark". For example, func BenchmarkMyFunction(b *testing.B) {}.

    Use the b.N value for iterations: The b parameter in the benchmark function provides a N field that represents the number of iterations to run the benchmark. Use this value in your code to repeat the operation being benchmarked.

    Use b.StartTimer() and b.StopTimer(): If your benchmark code includes setup or initialization that you don't want to measure, you can use b.StartTimer() and b.StopTimer() to exclude that part from the benchmark timing.

    Run benchmarks with the go test command: To execute benchmarks, use the go test -bench command followed by a regular expression that matches the benchmark function names. For example, go test -bench=., where . matches all benchmark functions.

    Analyze benchmark results: After running the benchmarks, Go will provide output that includes the execution time and other metrics for each benchmark. Analyze the results to compare the performance of different implementations or optimizations.

    Repeat benchmarks multiple times: Benchmark results can vary between runs due to factors such as CPU load or other system activities. To obtain more reliable results, run the benchmarks multiple times and observe the average or median values.

    Profile your code: Go provides various profiling tools such as go test -benchmem, go tool pprof, and go test -cpuprofile to profile memory usage, CPU performance, and more. Profiling can help identify potential bottlenecks and optimize critical parts of your code.

    Remember that benchmarks provide relative performance comparisons and should be conducted on representative datasets. It's essential to consider the real-world usage scenarios and optimize based on specific requirements rather than solely relying on benchmark results.

    For more detailed information and examples, refer to the official Go documentation on testing and benchmarking: https://golang.org/pkg/testing/


[Links]
1. https://tapajyoti-bose.medium.com/battle-of-the-giants-github-copilot-vs-chatgpt-%EF%B8%8F-%EF%B8%8F-d3ba6c116543
2. https://teivah.medium.com/how-to-write-accurate-benchmarks-in-go-4266d7dd1a95
3. https://github.com/01-edu/public/tree/master/subjects/lem-in/audit

[DONE]
1. Dual CMD. One for CLI. One for web. 

2. Check all endcases:
    - No end
    - No start
    - No connection
    - Duplicating rooms

3.  See Edmondsâ€“Karp algorithm and Dinic's algorithm. 

4.  Create a folder in usecases named pathfinders, which contain packages named after used algorithm.
    - Each file defines a struct that fits to the pathFinder interface.
    - The pathfinder file defines the interface for pathFinders. It also manages which algorithm to chose, based on the graph provided.

5.  Seems my builder cannot register all connections. Should check it. 

6.  When adding web interface, consider creating two methods of creating anthill: from text. And drawing.
    The easiest way would be making the frontend able to construct an input text simmilar to CLI input text.
                                    ---or---
    My builder will recieve only data needed to build a room, tunnel and anthill. The interface should just fit incoming data to it.
    No matter what are the incoming things.
    I chose the second option. It will be easier to fit web with its json.

7.  Right now my code does depth first search. This is bad because i might end up chosing longer paths,
    because they come first in a slice.
    A better way would be to implement a breadth first search. This will require either using hashmaps or queues.
    But I am thinking of an alternative. Use goroutines for start node's connections.
    This might be fruitful, as the maximum number of paths is equal to the number of connections of the start node (due to edge and node capacity being equal to 1).
    But then, problem arises when pathfinder chooses less optimal path within internal nodes. Should I use goroutines for internals as well??
    Might be cumbersome, as there is a limited number of goroutines per program. I would also need to use mutex to avoid data race,
    which again adds to complexity and computation time. Seems to be better to avoid goruotines at all.
    Implementing goroutines is also troublesome, because functions called with them cannot have return values.

8.  Should add some kind of queue maker algorithm. Builder yeilds an anthill. Pathfinder gives paths. But the solution
    consists not only of shortest paths. It actually tells how ants ants should be moving through the maze. That means -
    we need a queue maker. I don't know how presenter plays a role in it, but {solver = pathfinder + queuemaker}. 

9.  The idea seems that I must do the shortest path algorithm. Exclude nodes found in that path. Find next shortest path.
    Exclude these nodes as well. Repeat until there are no paths from start to end.

10.  It seems that there is an issue with several paths, i.e. repeated paths. For now I solve it with it by prohibitting
    duplicated lines. But if tunnel info is repeated by interchanging room names, this will create repeated tunnel (all my tunnels are biderictional). Somehow it seems very ok. In the instructions it is stated:

        ---A room can be linked to an infinite number of rooms and by as many tunnels as deemed necessary.---
    
    So, technically, it is just two tunnels connected by several tunnels. The task allows that. But ut might cause some problems to me. That is, if all tunnels are valid, it means only one will be used. It should not halt execturion,
    as each room has a mark called visited. But it will increase computation time, as it takes time to see all conections.
    So, I better ignore all repeating tunnels. Just keep one.

11.  For another pathfinder implementation (Dijkstra):
    https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7/

12.  Presenter will provide list of movements.

13. Gotta add all tests from intra and audit.

14. Example 5 is still too long. Cause: dijkstra working wrong. Fixed. Took away the visited flag.

15. Make all internal functions return string instead of println:
    entities.Anthill.Show(), path.PrinList()