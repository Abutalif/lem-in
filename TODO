[TODO]
1. find a way to switch between pathfinders, if there are two many steps.  (example1)
2. Standartize error message. Every message should start with "ERROR: invalid data format,. Use errors.Join().
3. Consider chaning your slices of pointers to either no pointer slices or Maps to pointers. Do it after benchmark testing.
4. In case if pathfinder finds num of path that is results in too many steps,
    there must be a function that changes a pathfinder.
    I have to mathematically find which path,
    depending on paths' length and num of ants results in smallest num of steps.

[Suggestions]
1. Might actaully try this (Dijkstra goroutine):
    https://stackoverflow.com/questions/70156258/golang-dijkstra-goroutines
2. Consider not following ants order. 


[DONE]
1. Dual CMD. One for CLI. One for web. 

2. Check all endcases:
    - No end
    - No start
    - No connection
    - Duplicating rooms

3.  See Edmondsâ€“Karp algorithm and Dinic's algorithm. 

4.  Create a folder in usecases named pathfinders, which contain packages named after used algorithm.
    - Each file defines a struct that fits to the pathFinder interface.
    - The pathfinder file defines the interface for pathFinders. It also manages which algorithm to chose, based on the graph provided.

5.  Seems my builder cannot register all connections. Should check it. 

6.  When adding web interface, consider creating two methods of creating anthill: from text. And drawing.
    The easiest way would be making the frontend able to construct an input text simmilar to CLI input text.
                                    ---or---
    My builder will recieve only data needed to build a room, tunnel and anthill. The interface should just fit incoming data to it.
    No matter what are the incoming things.
    I chose the second option. It will be easier to fit web with its json.

7.  Right now my code does depth first search. This is bad because i might end up chosing longer paths,
    because they come first in a slice.
    A better way would be to implement a breadth first search. This will require either using hashmaps or queues.
    But I am thinking of an alternative. Use goroutines for start node's connections.
    This might be fruitful, as the maximum number of paths is equal to the number of connections of the start node (due to edge and node capacity being equal to 1).
    But then, problem arises when pathfinder chooses less optimal path within internal nodes. Should I use goroutines for internals as well??
    Might be cumbersome, as there is a limited number of goroutines per program. I would also need to use mutex to avoid data race,
    which again adds to complexity and computation time. Seems to be better to avoid goruotines at all.
    Implementing goroutines is also troublesome, because functions called with them cannot have return values.

8.  Should add some kind of queue maker algorithm. Builder yeilds an anthill. Pathfinder gives paths. But the solution
    consists not only of shortest paths. It actually tells how ants ants should be moving through the maze. That means -
    we need a queue maker. I don't know how presenter plays a role in it, but {solver = pathfinder + queuemaker}. 

9.  The idea seems that I must do the shortest path algorithm. Exclude nodes found in that path. Find next shortest path.
    Exclude these nodes as well. Repeat until there are no paths from start to end.

10.  It seems that there is an issue with several paths, i.e. repeated paths. For now I solve it with it by prohibitting
    duplicated lines. But if tunnel info is repeated by interchanging room names, this will create repeated tunnel (all my tunnels are biderictional). Somehow it seems very ok. In the instructions it is stated:

        ---A room can be linked to an infinite number of rooms and by as many tunnels as deemed necessary.---
    
    So, technically, it is just two tunnels connected by several tunnels. The task allows that. But ut might cause some problems to me. That is, if all tunnels are valid, it means only one will be used. It should not halt execturion,
    as each room has a mark called visited. But it will increase computation time, as it takes time to see all conections.
    So, I better ignore all repeating tunnels. Just keep one.

11.  For another pathfinder implementation (Dijkstra):
    https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7/

12.  Presenter will provide list of movements.

13. Gotta add all tests from intra and audit.

14. Example 5 is still too long. Cause: dijkstra working wrong. Fixed. Took away the visited flag.

15. Make all internal functions return string instead of println:
    entities.Anthill.Show(), path.PrinList()